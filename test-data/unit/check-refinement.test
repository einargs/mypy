[case testRefinementLiteral]
from typing_extensions import Annotated
from refinement import *
def f0() -> Annotated[int, A, A > 5]:
    return 9
reveal_type(f0)  # N: Revealed type is "def () -> builtins.int{A: A > 5}"

def f1() -> Annotated[int, A, A > 5]:
    return 3  # E: refinement type check failed
reveal_type(f1)  # N: Revealed type is "def () -> builtins.int{A: A > 5}"

a: Annotated[int, V, V > 5] = 9
reveal_type(a)  # N: Revealed type is "builtins.int{V: V > 5}"

b: Annotated[int, A, A > 5] = 4  # E: refinement type check failed
reveal_type(b)  # N: Revealed type is "builtins.int{A: A > 5}"
[builtins fixtures/tuple.pyi]

[case testRefinementVariableOverlap]
from typing_extensions import Annotated
from refinement import *
a: Annotated[int, V, V > 5] = 9
b: Annotated[int, V, V > 5] = 9  # E: Tried to bind already bound refinement variable "V"

def f0(a: Annotated[int, V, V > 5], b: Annotated[int, V, V < 8]) -> None:  # E: Tried to bind already bound refinement variable "V"
    return None

# I think this should be fine
def f1(a: Annotated[int, V, V > 5]) -> Annotated[int, V, V > 3]:
    return a

def f2(a: Annotated[int, V, V > 5]) -> Annotated[int, V, V > 3]:
    b: Annotated[int, A, A > 7] = 10
    return b
[builtins fixtures/tuple.pyi]

[case testRefinementMember]
from typing_extensions import Annotated
from refinement import *
class Container:
    def __init__(self, value: int):
        self.value = value

def f0(c: Annotated[Container, A, A.value > 5]) -> Annotated[int, B, B > 4]:
    return c.value
reveal_type(f0)  # N: Revealed type is "def (c: __main__.Container{A: A.value > 5}) -> builtins.int{B: B > 4}"

def f1(c: Annotated[Container, A, A.value > 5]) -> Annotated[int, B, B > 4]:
    a: Annotated[Container, C, C.value > 6] = c  # E: refinement type check failed
    return a.value
[builtins fixtures/tuple.pyi]

[case testRefinementTuple]
from typing import Tuple
from typing_extensions import Annotated
from refinement import *

# TODO
a: Annotated[Tuple[int, int], A, A == (1, 1)] = (1, 1)

def f0(m: Annotated[Tuple[int, int], V, V == (5, 1)]) -> Annotated[int, A, A > 3]:
    return m[0]

def f1(
    m: Annotated[Tuple[int, int], V, V == (5, 1)]
) -> Annotated[int, A, A > 3]:
    return m[1]  # E: refinement type check failed
[builtins fixtures/tuple.pyi]

[case testRefinementMemberTuple]
from typing import Tuple
from typing_extensions import Annotated
from refinement import *
class array:
    shape: Tuple[int, ...]

def f0(
        m1: Annotated[array, V, V.shape == (1, 1)],
        m2: Annotated[array, A, A.shape == (2, 2)]
) -> Annotated[array, B, B.shape == (2, 2)]:
    return m2
reveal_type(f0)  # N: Revealed type is "def (m1: __main__.array{V: V.shape == (1, 1)}, m2: __main__.array{A: A.shape == (2, 2)}) -> __main__.array{B: B.shape == (2, 2)}"

def f1(
        m1: Annotated[array, V, V.shape == (1, 1)],
        m2: Annotated[array, A, A.shape == (2, 2)]
) -> Annotated[array, B, B.shape == (2, 2)]:
    return m1  # E: refinement type check failed
[builtins fixtures/tuple.pyi]

[case testRefinementComplexAssignment]
from typing import Tuple
from typing_extensions import Annotated
from refinement import *
class array:
    shape: Tuple[int, ...]

def f0(
    v: Annotated[array, V, V.shape == (1, 5)]
) -> Annotated[int, A, A > 0]:
    a: Annotated[int, B, B > 3] = v.shape[1]
    b = a

    c: Annotated[int, C, C > 4] = v.shape[1]  # E: refinement type check failed
    d: Annotated[int, X, X > 1] = a  # E: refinement type check failed
    e = d
    # f type checks even though d doesn't, because the errors are isolated.
    f: Annotated[int, Y, Y > 0] = e

    return v.shape[0]
[builtins fixtures/tuple.pyi]

[case testRefinementFloatingVars]
from typing import Tuple
from typing_extensions import Annotated
from refinement import *

class array:
    shape: Tuple[int, ...]

L = RefinementVar('L')
M = RefinementVar('M')
N = RefinementVar('N')

def g0(
        m: Annotated[array, A, A.shape == (X, Y)]
) -> Annotated[int, V, V == Y]:
    tup: Annotated[Tuple[int, ...], L, L == (X, Y)] = m.shape
    return tup[1]

def f0(
        m1: Annotated[array, A, A.shape == (X, Y)],
        m2: Annotated[array, B, B.shape == (Y, Z)],
        m3: Annotated[array, C, C.shape == (X, Z)]
) -> Annotated[int, V, V == Y]:
    tup: Annotated[Tuple[int, ...], L, L == (X, Z)] = m3.shape
    m: Annotated[int, M, M == Y] = m1.shape[1]
    n: Annotated[int, N, N == Z] = tup[1]
    return m2.shape[0]
[builtins fixtures/tuple.pyi]

[case testRefinementCalls]
from typing_extensions import Annotated
from refinement import *

def over5() -> Annotated[int, A, A > 5]:
    return 9

def over10() -> Annotated[int, A, A > 10]:
    return 11

def test_no_args() -> Annotated[int, A, A > 0]:
    a: Annotated[int, V, V > 3] = over5()
    return over5()

def f0(v: Annotated[int, V, V > 5]) -> Annotated[int, B, B > 4]:
    return v

def f1(m: Annotated[int, A, A > 7]) -> Annotated[int, B, B > 6]:
    return m

def f2(
    a: Annotated[int, A, A > 1], b: Annotated[int, B, B > 3]
) -> Annotated[int, C, C > 3]:
    return b

def test_call_args(m: Annotated[int, V, V > 9]) -> Annotated[int, A, A > 0]:
    other: Annotated[int, Y, Y > 8] = 9
    d: Annotated[int, Z, Z > 3] = f0(f1(8))
    a: Annotated[int, B, B > 3] = f0(f1(over10()))
    b: Annotated[int, C, C > 3] = f2(m, other)
    # TODO: give specific type error in regards to `m` being invalid maybe?
    c: Annotated[int, X, X > 3] = m  # E: refinement type check failed
    return a

[builtins fixtures/tuple.pyi]

[case testRefinementVarInvalidation]
from typing_extensions import Annotated
from refinement import *

def f0(a: int) -> None:
    return None

def f1(a: int) -> Annotated[int, A, A > 3]:
    return 5

def f2(a: Annotated[int, A, A > 3]) -> Annotated[int, B, B == A]:
    return a

def f3(a: Annotated[int, A, A > 3]) -> None:
    return None

a: Annotated[int, A, A > 1] = 2
f0(a)
b: Annotated[int, B, B > 0] = a  # E: refinement type check failed

def b0(a0: Annotated[int, A, A > 10]) -> None:
    a1 = a0
    f3(a0)  # E: refinement type check failed
    f3(a1)
    x: Annotated[int, X, X > 3] = 7
    y: Annotated[int, Y, Y > 3] = f1(x)
    # This works because no type info from x is needed
    z: Annotated[int, Z, Z > 2] = f1(x)
    v: Annotated[int, V, V > 2] = x  # E: refinement type check failed
    c: Annotated[int, C, C > 1] = f2(x)  # E: refinement type check failed
[builtins fixtures/tuple.pyi]

[case testRefinementRevealDoesNotInvalidate]
from typing_extensions import Annotated
from refinement import *

def f0(v: Annotated[int, V, V > 0]) -> None:
    return None

def f1(v: Annotated[int, V]) -> Annotated[int, A, A == V]:
    return v

a: Annotated[int, A, A > 10] = 11
reveal_type(a)  # N: Revealed type is "builtins.int{A: A > 10}"
b: Annotated[int, B, B > 8] = a
reveal_type(a)  # N: Revealed type is "builtins.int{A: A > 10}"
c: Annotated[int, C, 5 < C] = a  # E: refinement type check failed


x: Annotated[int, X, 3 < X] = 5
reveal_type(x)  # N: Revealed type is "builtins.int{X: 3 < X}"
y = x
f0(x)  # E: refinement type check failed
f1(y)
reveal_type(y)  # N: Revealed type is "builtins.int{X: 3 < X}"
# TODO: Ideally we would catch the fact that x is invalid here, instead of when
# we use z.
z = f1(x)
f0(z)  # E: refinement type check failed
[builtins fixtures/tuple.pyi]

[case testRefinementExprStmt]
from typing_extensions import Annotated
from refinement import *

def f(i: Annotated[int, A, A > 5]) -> None:
    return None

f(1)  # E: refinement type check failed

f(8)
[builtins fixtures/tuple.pyi]

[case testRefinementEmptyConstraints]
from typing_extensions import Annotated
from refinement import *

a: Annotated[int, C] = 1

def f0(i: Annotated[int, A]) -> None:
    return None

f0(1)

def f1(i: Annotated[int, B]) -> Annotated[int, X, X == 5]:
    return 5

k: Annotated[int, V, V == 5] = f1(6)

[builtins fixtures/tuple.pyi]

[case testRefinementCallSubstitution]
from typing_extensions import Annotated
from refinement import *

def eq_arg(i: Annotated[int, A]) -> Annotated[int, B, B == A]:
    return i

a: Annotated[int, C, C == 5] = eq_arg(5)
b = eq_arg(5)

reveal_type(b)  # N: Revealed type is "builtins.int{B: B == 5}"
reveal_type(eq_arg(5))  # N: Revealed type is "builtins.int{B: B == 5}"

[builtins fixtures/tuple.pyi]

[case testRefinementVarMutation]
from typing_extensions import Annotated
from refinement import *

# TODO: currently this gets overwritten. In the future I might want a mechanism
# to allow direct declaration to be maintained.
a: Annotated[int, A, A > 5] = 6
a = 7
a = 3  # TODO: refinement type check failed
[builtins fixtures/tuple.pyi]

[case testRefinementMembers]
from typing_extensions import Annotated
from refinement import *

class Test:
    def __init__(self, i: Annotated[int, A, A > 5]):
        self.i = i

    def over4(self) -> Annotated[int, B, B > 4]:
        return self.i

    def __call__(self, i: Annotated[int, B, B < 20]) -> Annotated[int, C, C > 3]:
        return self.i

test0 = Test(3)  # E: refinement type check failed
test1 = Test(8)

test1(24)  # E: refinement type check failed
test1(19)

[builtins fixtures/tuple.pyi]

[case testRefinementVarScoping]
from typing_extensions import Annotated
from refinement import *

def f() -> Annotated[int, C, C > 1]:
    return 2

def block0() -> None:
    c: Annotated[int, C, 10 < C] = 12
    x = f()
    reveal_type(x)  # N: Revealed type is "builtins.int{C: C > 1}"
    reveal_type(c)  # N: Revealed type is "builtins.int{C: 10 < C}"

def block1() -> None:
    c: Annotated[int, C, 10 < C] = 12
    x = f()
    reveal_type(x)  # N: Revealed type is "builtins.int{C: C > 1}"
    a: Annotated[int, A, A >= 11] = c
[builtins fixtures/tuple.pyi]

[case testRefinementArithmetic]
from typing_extensions import Annotated
from refinement import *

def f0(
    a: Annotated[int, A, A > 3],
    b: Annotated[int, B, B > 3]
) -> Annotated[int, C, C > A+B]: ...

a: Annotated[int, A, A > 1+2] = 5
b: Annotated[int, B, B > 3+3] = f0(4,6)
c: Annotated[int, Y, Y > 1+3] = 4  # E: refinement type check failed
x0 = f0(5,5)
reveal_type(x0)  # N: Revealed type is "builtins.int{C: C > 5 + 5}"
x1 = f0(5,5)
x2: Annotated[int, X, X > 4] = x1
[builtins fixtures/tuple.pyi]

[case testRefinementTermArithmetic]
from typing import Tuple
from typing_extensions import Annotated
from refinement import *

v: int = 1 + 1

k = 3 + 5
j: Annotated[int, V, V > 5] = k

def f0(
    a: Annotated[int, A, A > 3],
    b: Annotated[int, B, B > 4]
) -> Annotated[int, C, C > A+B]:
    return a + b + 1

def block0() -> None:
    a: Annotated[int, A, A > 1+2] = 4+4
    b: Annotated[int, B, B > 3+A] = f0(4,6) + a
    c: Annotated[int, C, C > 1+3] = 4  # E: refinement type check failed
    x: Annotated[int, X, X > 6] = f0(4,6) - 1

def new_scope() -> Annotated[int, V, V > 4]:
    a: Annotated[int, A, A > 6] = f0(4,5)
    # For `b`, even though locally f0 only knows that the return value has to be
    # at least greater than 9, here it knows the local constraints on the
    # substituted values.
    b: Annotated[int, B, B > 6] = f0(4,10) - 8
    x: Annotated[int, X, X > 3] = 4
    c: Annotated[int, C, C > 6] = f0(x,10) - 9  # E: refinement type check failed
    y: Annotated[int, Y, Y == 4] = 19 // 4

    return f0(a,b)

def f1(
    v: Annotated[Tuple[int, int], V, V[0] > 1, V[1] > 2]
) -> Annotated[Tuple[int, int], X, X == (V[0]+3, V[1]+3)]:
    return (v[0] + 3, v[1] + 3)

def block1() -> None:
    x: Annotated[Tuple[int, int], X, X == (6,6)] = f1((3,3))
    y: Annotated[Tuple[int, int], Y, Y == (6,6)] = f1((1,3))  # E: refinement type check failed
[builtins fixtures/ops.pyi]

[case testRefinementTupleTerm]
from typing import Tuple
from typing_extensions import Annotated
from refinement import *

v: Annotated[Tuple[int, int, int], V, V == (1,2,3)] = (1,2,3)

def f0(
    v: Annotated[Tuple[int, int], V, V[0] > 1, V[1] > 2]
) -> Annotated[Tuple[int, int], X, X == (V[0], V[1])]:
    return (v[0], v[1])

x: Annotated[Tuple[int, int], X, X[0] > 4, X[1] > 5] = f0((6,6))

# TODO: there are problems with tuple equality. Basically it's creating a
# constraint as if X and V are integers instead of tuples. I may need to either
# introduce types or switch to using `is` instead of `==` for tuple expansion.
def f1(v: Annotated[Tuple[int, int], V]) -> Annotated[Tuple[int, int], X, X == (V[0], V[1])]:
    return (v[0], v[1])

def f2(
    v: Annotated[Tuple[int, int], V]
) -> Annotated[Tuple[int, int], X, X[0] == V[0], X[1] == V[1]]:
    return (v[0], v[1])

def f3() -> Annotated[Tuple[int, int], A, A[0] == 4, A[1] == 4]:
    return (4, 4)

a: Annotated[Tuple[int, int], A, A == (4, 4)] = f1(f2(f3()))

def f4(v: Annotated[Tuple[int, int], V, V[0] > 1, V[1] > 2]) -> None:
    return None

f4(f2((3,3)))
[builtins fixtures/primitives.pyi]

[case testRefinementRSelf]
from typing_extensions import Annotated
from refinement import *

class Test0:
    def __init__(self, x: Annotated[int, X, X > 2]) -> Annotated[None, RSelf.x == X]:
        self.x = x
        b: Annotated[int, B, B > 0] = self.x

def block0() -> None:
    a: Annotated[Test0, A, A.x > 10] = Test0(11)
    b: Annotated[Test0, B, B.x < 10] = Test0(x=8)
    v: Annotated[Test0, V, V.x > 10] = Test0(x=8) # E: refinement type check failed

class Test1:
    def __init__(self: 'Test1', x: Annotated[int, X, X > 2]) -> Annotated[None, RSelf.x == X, RSelf.x > 0]:
        self.x = x

def block1() -> None:
    a: Annotated[Test1, A, A.x > 10] = Test1(11)
    b: Annotated[Test1, B, B.x < 10] = Test1(x=8)
[builtins fixtures/primitives.pyi]

[case testRefinementStoredRSelf]
from typing_extensions import Annotated
from refinement import *

SELF = RefinementVar('SELF')

class Prop0:
    def __init__(self: 'Prop0', x: Annotated[int, X]) -> Annotated[None, RSelf.x == X]:
        self.x = x

class Test0:
    def __init__(self, c: Annotated[int, C]) -> Annotated[None, RSelf.c == C]:
        self.prop = Prop0(2)
        self.c = c

    def useX(self: Annotated['Test0', SELF], a: Annotated[int, A]) -> Annotated[int, V, V == SELF.c * A * SELF.prop.x]:
        otherProp: Annotated[Prop0, X, X.x == 2] = self.prop
        # TODO: return to this once I have constants and post conditions
        # implemented.
        return self.c * a * self.prop.x

    def useProp(self: Annotated['Test0', SELF]) -> Annotated[int, V, V == 2]:
        inferred = self.prop
        otherProp: Annotated['Prop0', X, X.x == 2] = inferred
        return otherProp.x

    def __call__(self: Annotated['Test0', SELF]) -> Annotated[int, V, V == SELF.c * 2]:
        return self.c * 2

def block0() -> Annotated[int, X]:
    test = Test0(2)
    a: Annotated[int, A, A == 8] = test.useX(2)

    return 0

class Thing:
    prop: int

def f0() -> Annotated[Thing, V, V.prop == 2]: ...

def block1() -> Annotated[int, X]:
    test = Test0(2)
    b: Annotated[int, B, B == 4] = test()

    return 0
[builtins fixtures/ops.pyi]

[case testRefinementArgDeps]
from typing_extensions import Annotated
from refinement import *

SELF = RefinementVar('SELF')

def f0(a: Annotated[int, A], b: Annotated[int, B, B == A]) -> None: ...

f0(0, 0)

class Test0:
    def __init__(self, c: Annotated[int, C]) -> Annotated[None, RSelf.c == C]:
        self.c = c

    def deps(self: Annotated['Test0', SELF], arg: Annotated[int, V, V == SELF.c]) -> None: ...

test = Test0(1)

test.deps(1)
test.deps(2) # E: refinement type check failed
[builtins fixtures/primitives.pyi]

[case testRefinementConst]
from typing_extensions import Annotated
from refinement import *

def f0(x: Annotated[int, X, X > 3]) -> None:
    y = x
    z: Annotated[int, Z, Z > 2] = x # E: refinement type check failed

def f1() -> None:
    x: Annotated[int, X, Const, X > 3] = 5
    y = x
    z: Annotated[int, Z, Z > 2] = x

def f2(x: Annotated[int, X, Const, X > 3]) -> None:
    y = x
    z: Annotated[int, Z, Z > 1] = 2
    y = z

def f3() -> None:
    x: Annotated[int, X, Const, X > 3] = 4
    # TODO: currently even this will be overwritten. In the future I might want
    # this to work.
    z: Annotated[int, Z, Z > 6] = 8
    x = z
    x = 2 # TODO: refinement type check failed

def f4(input: Annotated[int, V, V > 3]) -> None:
    x: Annotated[int, X, X == 1] = 1
    y: Annotated[int, Y, Y == 2] = 2
    z: Annotated[int, Z, Z == 3] = 3

    a = x
    a = y
    a = z
    b: Annotated[int, B, B == 3] = a
[builtins fixtures/primitives.pyi]

[case testRefinementReUse]
from typing_extensions import Annotated
from refinement import *

def inc(x: Annotated[int, X]) -> Annotated[int, V, V == X + 1]:
    return x + 1

def f0(input: Annotated[int, V, V == 0]) -> None:
    a = inc(input)
    a = inc(a)
    a = inc(a)
    b: Annotated[int, B, B == 4] = inc(a)

class Container:
    def __init__(self, x: Annotated[int, X]) -> Annotated[None, RSelf.x == X]:
        self.x = x

def incCon(x: Annotated[Container, X]) -> Annotated[Container, V, V.x == X.x + 1]:
    return Container(x.x + 1)

def f1(input: Annotated[Container, V, V.x == 0]) -> None:
    a = incCon(input)
    a = incCon(a)
    a = incCon(a)
    b: Annotated[Container, B, B.x == 4] = incCon(a)

[builtins fixtures/ops.pyi]
