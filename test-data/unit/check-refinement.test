[case testRefinementLiteral]
from typing_extensions import Annotated
from refinement import *
def f0() -> Annotated[int, A, A > 5]:
    return 9
reveal_type(f0)  # N: Revealed type is "def () -> builtins.int{A: A > 5}"

def f1() -> Annotated[int, A, A > 5]:
    return 3  # E: refinement type check failed
reveal_type(f1)  # N: Revealed type is "def () -> builtins.int{A: A > 5}"

a: Annotated[int, V, V > 5] = 9
reveal_type(a)  # N: Revealed type is "builtins.int{V: V > 5}"

b: Annotated[int, A, A > 5] = 4  # E: refinement type check failed
reveal_type(b)  # N: Revealed type is "builtins.int{A: A > 5}"
[builtins fixtures/tuple.pyi]

[case testRefinementVariableOverlap]
from typing_extensions import Annotated
from refinement import *
a: Annotated[int, V, V > 5] = 9
b: Annotated[int, V, V > 5] = 9  # E: Tried to bind already bound refinement variable "V"

def f0(a: Annotated[int, V, V > 5], b: Annotated[int, V, V < 8]) -> None:  # E: Tried to bind already bound refinement variable "V"
    return None

# I think this should be fine
def f1(a: Annotated[int, V, V > 5]) -> Annotated[int, V, V > 3]:
    return a

def f2(a: Annotated[int, V, V > 5]) -> Annotated[int, V, V > 3]:
    b: Annotated[int, A, A > 7] = 10
    return b
[builtins fixtures/tuple.pyi]

[case testRefinementMember]
from typing_extensions import Annotated
from refinement import *
class Container:
    def __init__(self, value: int):
        self.value = value

def f0(c: Annotated[Container, A, A.value > 5]) -> Annotated[int, B, B > 4]:
    return c.value
reveal_type(f0)  # N: Revealed type is "def (c: __main__.Container{A: A.value > 5}) -> builtins.int{B: B > 4}"

def f1(c: Annotated[Container, A, A.value > 5]) -> Annotated[int, B, B > 4]:
    a: Annotated[Container, C, C.value > 6] = c  # E: refinement type check failed
    return a.value
[builtins fixtures/tuple.pyi]

[case testRefinementTuple]
from typing import Tuple
from typing_extensions import Annotated
from refinement import *

# TODO
a: Annotated[Tuple[int, int], A, A == (1, 1)] = (1, 1)  # E: Tuple expressions are not yet implemented

def f0(m: Annotated[Tuple[int, int], V, V == (5, 1)]) -> Annotated[int, A, A > 3]:
    return m[0]

def f1(
    m: Annotated[Tuple[int, int], V, V == (5, 1)]
) -> Annotated[int, A, A > 3]:
    return m[1]  # E: refinement type check failed
[builtins fixtures/tuple.pyi]

[case testRefinementMemberTuple]
from typing import Tuple
from typing_extensions import Annotated
from refinement import *
class array:
    shape: Tuple[int, ...]

def f0(
        m1: Annotated[array, V, V.shape == (1, 1)],
        m2: Annotated[array, A, A.shape == (2, 2)]
) -> Annotated[array, B, B.shape == (2, 2)]:
    return m2
reveal_type(f0)  # N: Revealed type is "def (m1: __main__.array{V: V.shape == (1, 1)}, m2: __main__.array{A: A.shape == (2, 2)}) -> __main__.array{B: B.shape == (2, 2)}"

def f1(
        m1: Annotated[array, V, V.shape == (1, 1)],
        m2: Annotated[array, A, A.shape == (2, 2)]
) -> Annotated[array, B, B.shape == (2, 2)]:
    return m1  # E: refinement type check failed
[builtins fixtures/tuple.pyi]

[case testRefinementComplexAssignment]
from typing import Tuple
from typing_extensions import Annotated
from refinement import *
class array:
    shape: Tuple[int, ...]

def f0(
    v: Annotated[array, V, V.shape == (1, 5)]
) -> Annotated[int, A, A > 0]:
    a: Annotated[int, B, B > 3] = v.shape[1]
    b = a

    c: Annotated[int, C, C > 4] = v.shape[1]  # E: refinement type check failed
    d: Annotated[int, X, X > 1] = a  # E: refinement type check failed
    e = d
    # f type checks even though d doesn't, because the errors are isolated.
    f: Annotated[int, Y, Y > 0] = e

    return v.shape[0]
[builtins fixtures/tuple.pyi]

[case testRefinementFloatingVars]
from typing import Tuple
from typing_extensions import Annotated
from refinement import *

class array:
    shape: Tuple[int, ...]

L = RefinementVar('L')
M = RefinementVar('M')
N = RefinementVar('N')

def f0(
        m1: Annotated[array, A, A.shape == (X, Y)],
        m2: Annotated[array, B, B.shape == (Y, Z)],
        m3: Annotated[array, C, C.shape == (X, Z)]
) -> Annotated[int, V, V == Y]:
    tup: Annotated[Tuple[int, ...], L, L == (X, Z)] = m3.shape
    m: Annotated[int, M, M == Y] = m1.shape[1]
    n: Annotated[int, N, N == Z] = tup[1]
    return m2.shape[0]
[builtins fixtures/tuple.pyi]

[case testRefinementCalls]
from typing_extensions import Annotated
from refinement import *

def over5() -> Annotated[int, A, A > 5]:
    return 9

def over10() -> Annotated[int, A, A > 10]:
    return 11

def test_no_args() -> Annotated[int, A, A > 0]:
    a: Annotated[int, V, V > 3] = over5()
    return over5()

def f0(v: Annotated[int, V, V > 5]) -> Annotated[int, B, B > 4]:
    return v

def f1(m: Annotated[int, A, A > 7]) -> Annotated[int, B, B > 6]:
    return m

def f2(
    a: Annotated[int, A, A > 1], b: Annotated[int, B, B > 3]
) -> Annotated[int, C, C > 3]:
    return b

def test_call_args(m: Annotated[int, V, V > 9]) -> Annotated[int, A, A > 0]:
    other: Annotated[int, Y, Y > 8] = 9
    d: Annotated[int, Z, Z > 3] = f0(f1(8))
    a: Annotated[int, B, B > 3] = f0(f1(over10()))
    b: Annotated[int, C, C > 3] = f2(m, other)
    # TODO: give specific type error in regards to `m` being invalid maybe?
    c: Annotated[int, X, X > 3] = m  # E: refinement type check failed
    return a

[builtins fixtures/tuple.pyi]

[case testRefinementVarInvalidation]
from typing_extensions import Annotated
from refinement import *

def f0(a: int) -> None:
    return None

def f1(a: int) -> Annotated[int, A, A > 3]:
    return 5

def f2(a: Annotated[int, A, A > 3]) -> Annotated[int, B, B == A]:
    return a

def f3(a: Annotated[int, A, A > 3]) -> None:
    return None

a: Annotated[int, A, A > 1] = 2
f0(a)
b: Annotated[int, B, B > 0] = a  # E: refinement type check failed

def b0(a0: Annotated[int, A, A > 10]) -> None:
    a1 = a0
    f3(a0)  # E: refinement type check failed
    f3(a1)
    x: Annotated[int, X, X > 3] = 7
    y: Annotated[int, Y, Y > 3] = f1(x)
    # This works because no type info from x is needed
    z: Annotated[int, Z, Z > 2] = f1(x)
    v: Annotated[int, V, V > 2] = x  # E: refinement type check failed
    c: Annotated[int, C, C > 1] = f2(x)  # E: refinement type check failed
[builtins fixtures/tuple.pyi]

[case testRefinementExprStmt]
from typing_extensions import Annotated
from refinement import *

def f(i: Annotated[int, A, A > 5]) -> None:
    return None

f(1)  # E: refinement type check failed

f(8)
[builtins fixtures/tuple.pyi]

[case testRefinementEmptyConstraints]
from typing_extensions import Annotated
from refinement import *

a: Annotated[int, C] = 1

def f0(i: Annotated[int, A]) -> None:
    return None

f0(1)

def f1(i: Annotated[int, B]) -> Annotated[int, X, X == 5]:
    return 5

k: Annotated[int, V, V == 5] = f1(6)

[builtins fixtures/tuple.pyi]

[case testRefinementCallSubstitution]
from typing_extensions import Annotated
from refinement import *

def eq_arg(i: Annotated[int, A]) -> Annotated[int, B, B == A]:
    return i

a: Annotated[int, C, C == 5] = eq_arg(5)
b = eq_arg(5)

reveal_type(b)  # N: Revealed type is "builtins.int{B: B == 5}"
reveal_type(eq_arg(5))  # N: Revealed type is "builtins.int{B: B == 5}"

[builtins fixtures/tuple.pyi]

[case testRefinementVarMutation]
from typing_extensions import Annotated
from refinement import *

a: Annotated[int, A, A > 5] = 6
a = 7
a = 3  # E: refinement type check failed

[builtins fixtures/tuple.pyi]

[case testRefinementMembers]
from typing_extensions import Annotated
from refinement import *

class Test:
    def __init__(self, i: Annotated[int, A, A > 5]):
        self.i = i

    def over4(self) -> Annotated[int, B, B > 4]:
        return self.i

    def __call__(self, i: Annotated[int, B, B < 20]) -> Annotated[int, C, C > 3]:
        return self.i

test0 = Test(3)  # E: refinement type check failed
test1 = Test(8)

test1(24)  # E: refinement type check failed
test1(19)

[builtins fixtures/tuple.pyi]

[case testRefinementVarScoping]
from typing_extensions import Annotated
from refinement import *

def f() -> Annotated[int, C, C > 1]:
    return 2

c: Annotated[int, C, C > 10] = 12
# The below errors because the C from `f()` is not properly scoped.
x = f()
[builtins fixtures/tuple.pyi]

[case testRefinementArithmetic]
from typing_extensions import Annotated
from refinement import *

def f0(
    a: Annotated[int, A, A > 3],
    b: Annotated[int, B, B > 3]
) -> Annotated[int, C, C > A+B]: ...

a: Annotated[int, A, A > 1+2] = 5
b: Annotated[int, B, B > 3+3] = f0(4,6)
c: Annotated[int, Y, Y > 1+3] = 4  # E: refinement type check failed
x0 = f0(5,5)
reveal_type(x0)  # N: Revealed type is "builtins.int{C: C > 5 + 5}"
x1 = f0(5,5)
x2: Annotated[int, X, X > 4] = x1
[builtins fixtures/tuple.pyi]

[case testRefinementTermArithmetic]
from typing_extensions import Annotated
from refinement import *

v: int = 1 + 1

k = 3 + 5
j: Annotated[int, V, V > 5] = k

def f0(
    a: Annotated[int, A, A > 3],
    b: Annotated[int, B, B > 4]
) -> Annotated[int, C, C > A+B]:
    return a + b + 1

a: Annotated[int, A, A > 1+2] = 4+4
b: Annotated[int, B, B > 3+A] = f0(4,6) + a
c: Annotated[int, C, C > 1+3] = 4  # E: refinement type check failed
x: Annotated[int, X, X > 6] = f0(4,6) - 1

def new_scope() -> Annotated[int, V, V > 4]:
    a: Annotated[int, A, A > 6] = f0(4,5)
    # For `b`, even though locally f0 only knows that the return value has to be
    # at least greater than 9, here it knows the local constraints on the
    # substituted values.
    b: Annotated[int, B, B > 6] = f0(4,10) - 8
    x: Annotated[int, X, X > 3] = 4
    c: Annotated[int, C, C > 6] = f0(x,10) - 9  # E: refinement type check failed
    y: Annotated[int, Y, Y == 4] = 19 // 4

    return f0(a,b)
[builtins fixtures/ops.pyi]
